"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GraphQLService = exports.ConnectionStatus = void 0;
const WebSocket = require("isomorphic-ws");
const rxjs_1 = require("rxjs");
const graphql_batcher_1 = require("../graphql-batcher");
const operators_1 = require("rxjs/operators");
class Subscription {
    constructor(id, query) {
        this.id = id;
        this.query = query;
    }
}
var MessageType;
(function (MessageType) {
    // To Server
    MessageType["GQL_CONNECTION_INIT"] = "connection_init";
    MessageType["GQL_START"] = "start";
    MessageType["GQL_STOP"] = "stop";
    // From Server
    MessageType["GQL_CONNECTION_ACK"] = "connection_ack";
    MessageType["GQL_DATA"] = "data";
    MessageType["GQL_CONNECTION_KEEP_ALIVE"] = "ka";
    MessageType["GQL_COMPLETE"] = "complete";
})(MessageType || (MessageType = {}));
var ConnectionStatus;
(function (ConnectionStatus) {
    ConnectionStatus["DISCONNECTED"] = "DISCONNECTED";
    ConnectionStatus["CONNECTING"] = "CONNECTING";
    ConnectionStatus["INITIALIZING"] = "INITIALIZING";
    ConnectionStatus["CONNECTED"] = "CONNECTED";
})(ConnectionStatus = exports.ConnectionStatus || (exports.ConnectionStatus = {}));
/**
 * A service that lets the user query Qminder API via GraphQL statements.
 * Queries and subscriptions are supported. There is no support for mutations.
 *
 * Note: the GraphQL API is accessible via `Qminder.graphql`. You should use that, instead of
 * trying to import GraphQLService.
 */
class GraphQLService {
    constructor() {
        this.socket = null;
        this.connectionSubject = new rxjs_1.Subject();
        this.connection$ = this.connectionSubject.pipe(operators_1.shareReplay(1));
        this.nextSubscriptionId = 1;
        this.subscriptions = [];
        this.subscriptionObserverMap = {};
        /** Counts the amount of times the event emitter retried connecting. This is used for
         *  exponential retry falloff. */
        this.connectionRetries = 0;
        this.batcher = new graphql_batcher_1.GraphqlBatcher();
        this.setServer('wss://api.qminder.com:443');
        this.setConnectionStatus(ConnectionStatus.DISCONNECTED);
    }
    /**
     * Query Qminder API with GraphQL.
     *
     * Send a GraphQL query to the Qminder API.
     *
     * When the query contains variables, make sure to fill them all in the second parameter.
     *
     * For example:
     *
     * ```javascript
     * import * as Qminder from 'qminder-api';
     * Qminder.setKey('API_KEY_HERE');
     * // 1. Figure out the selected location ID of the current user, with async/await
     * try {
     *     const response = await Qminder.graphql.query(`{ me { selectedLocation } }`);
     *     console.log(response.me.selectedLocation); // "12345"
     * } catch (error) {
     *     console.log(error);
     * }
     * // 2. Figure out the selected location ID of the current user, with promises
     * Qminder.graphql.query("{ me { selectedLocation } }").then(function(response) {
     *     console.log(response.me.selectedLocation);
     * }, function(error) {
     *     console.log(error);
     * });
     * ```
     *
     * @param query required: the query to send, for example `"{ me { selectedLocation } }"`
     * @param variables optional: additional variables for the query, if variables were used
     * @returns a promise that resolves to the query's results, or rejects if the query failed
     * @throws when the 'query' argument is undefined or an empty string
     */
    query(query, variables) {
        if (!query || query.length === 0) {
            throw new Error('GraphQLService query expects a GraphQL query as its first argument');
        }
        return this.batcher.submit(query, variables);
    }
    /**
     * Subscribe to Qminder Events API using GraphQL.
     *
     * For example
     *
     * ```javascript
     * import * as Qminder from 'qminder-api';
     * // 1. Be notified of any created tickets
     * try {
     *     const observable = Qminder.graphql.subscribe("createdTickets(locationId: 123) { id firstName }")
     *
     *     observable.subscribe(data => console.log(data));
     *     // => { createdTickets: { id: '12', firstName: 'Marta' } }
     * } catch (error) {
     *     console.error(error);
     * }
     * ```
     *
     * @param query required: the GraphQL query to send, for example `"createdTickets(locationId: 123) { id firstName }"`
     * @returns an RxJS Observable that will push data as
     * @throws when the 'query' argument is undefined or an empty string
     */
    subscribe(query) {
        if (!query || query.length === 0) {
            throw new Error('GraphQLService query expects a GraphQL query as its first argument');
        }
        return new rxjs_1.Observable((observer) => {
            const id = this.generateOperationId();
            this.subscriptions.push(new Subscription(id, query));
            this.sendMessage(id, MessageType.GQL_START, { query: `subscription { ${query} }` });
            this.subscriptionObserverMap[id] = observer;
            return () => this.stopSubscription(id);
        });
    }
    /**
     * Initialize the EventsService by setting the API key.
     * When the API key is set, the socket can be opened.
     * This method is automatically called when doing Qminder.setKey().
     * @hidden
     */
    setKey(apiKey) {
        this.apiKey = apiKey;
    }
    /**
     * Get subscription connection observable
     * This returns an observable which fires with the connection status every time it changes.
     * @returns an RxJS obserable that will fire with the connection status every time it changes
     */
    getSubscriptionConnectionObservable() {
        return this.connection$;
    }
    /**
     * Set the WebSocket hostname the GraphQL service uses.
     * @hidden
     */
    setServer(apiServer) {
        this.apiServer = apiServer;
    }
    stopSubscription(id) {
        this.sendMessage(id, MessageType.GQL_STOP, null);
        delete this.subscriptionObserverMap[id];
        this.subscriptions = this.subscriptions.filter((sub) => {
            return sub.id !== id;
        });
    }
    openSocket() {
        if (this.connectionStatus != ConnectionStatus.DISCONNECTED) {
            return;
        }
        this.setConnectionStatus(ConnectionStatus.CONNECTING);
        const socket = new WebSocket(`${this.apiServer}/graphql/subscription?rest-api-key=${this.apiKey}`);
        this.socket = socket;
        socket.onopen = () => {
            console.log('[GraphQL subscription] Connection established!');
            this.setConnectionStatus(ConnectionStatus.INITIALIZING);
            this.connectionRetries = 0;
            this.sendMessage(undefined, MessageType.GQL_CONNECTION_INIT, null);
        };
        socket.onclose = (event) => {
            // NOTE: if the event code is 1006, it is any of the errors in the list here:
            // https://www.w3.org/TR/websockets/#concept-websocket-close-fail
            console.log('[GraphQL subscription] Connection lost: ' + event.code);
            this.setConnectionStatus(ConnectionStatus.DISCONNECTED);
            this.socket = null;
            // If it wasn't a client-side close socket, retry connecting.
            if (event.code !== 1000) {
                // Increase the retry timeout, the more times we retry
                const timeoutMult = Math.floor(this.connectionRetries / 10);
                const newTimeout = Math.min(5000 + timeoutMult * 1000, 60000);
                if (this.retryTimeout) {
                    clearTimeout(this.retryTimeout);
                }
                console.log('[GraphQL subscription] Reconnecting in ' + newTimeout / 1000 + ' seconds...');
                this.retryTimeout = setTimeout(this.openSocket.bind(this), newTimeout);
                this.connectionRetries++;
            }
        };
        socket.onerror = () => {
            console.log('[GraphQL subscription] An error occurred, the websocket will disconnect.');
        };
        socket.onmessage = (rawMessage) => {
            var _a, _b, _c, _d;
            if (typeof rawMessage.data === 'string') {
                const message = JSON.parse(rawMessage.data);
                switch (message.type) {
                    case MessageType.GQL_CONNECTION_KEEP_ALIVE:
                        break;
                    case MessageType.GQL_CONNECTION_ACK:
                        this.setConnectionStatus(ConnectionStatus.CONNECTED);
                        this.subscriptions.forEach((subscription) => {
                            const payload = { query: `subscription { ${subscription.query} }` };
                            const message = JSON.stringify({ id: subscription.id, type: MessageType.GQL_START, payload });
                            this.sendRawMessage(message);
                        });
                        break;
                    case MessageType.GQL_DATA:
                        (_a = this.subscriptionObserverMap[message.id]) === null || _a === void 0 ? void 0 : _a.next(message.payload.data);
                        break;
                    case MessageType.GQL_COMPLETE:
                        (_b = this.subscriptionObserverMap[message.id]) === null || _b === void 0 ? void 0 : _b.complete();
                        break;
                    default:
                        if (message.payload && message.payload.data) {
                            (_c = this.subscriptionObserverMap[message.id]) === null || _c === void 0 ? void 0 : _c.error(message.payload.data);
                        }
                        else if (message.errors && message.errors.length > 0) {
                            (_d = this.subscriptionObserverMap[message.id]) === null || _d === void 0 ? void 0 : _d.error(message.errors);
                        }
                }
            }
        };
    }
    sendMessage(id, type, payload) {
        const message = JSON.stringify({ id, type, payload });
        if (this.connectionStatus === ConnectionStatus.CONNECTED || this.connectionStatus === ConnectionStatus.INITIALIZING) {
            this.sendRawMessage(message);
        }
        else {
            this.openSocket();
        }
    }
    sendRawMessage(message) {
        this.socket.send(message);
    }
    generateOperationId() {
        return String(this.nextSubscriptionId++);
    }
    setConnectionStatus(status) {
        this.connectionStatus = status;
        this.connectionSubject.next(status);
    }
}
exports.GraphQLService = GraphQLService;
exports.default = new GraphQLService();
