"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GraphqlBatcher = exports.GraphqlBatcherError = void 0;
const api_base_1 = require("./api-base");
class GraphqlBatcherError extends Error {
    constructor(message, errors) {
        super(message);
        this.message = message;
        this.errors = errors;
    }
}
exports.GraphqlBatcherError = GraphqlBatcherError;
class GraphqlBatcher {
    constructor() {
        this.queries = [];
    }
    submit(query, variables) {
        if (!this.timeout) {
            this.timeout = setTimeout(this.runBatch.bind(this), 50);
        }
        let callbackResolve = null;
        let callbackReject = null;
        const promise = new Promise(((resolve, reject) => {
            callbackResolve = resolve;
            callbackReject = reject;
        }));
        const packedQuery = query.replace(/\s\s+/g, ' ').trim();
        if (!variables) {
            let existingPendingQuery = this.queries.find(q => q.query === packedQuery);
            if (existingPendingQuery) {
                existingPendingQuery.callbacks.push({
                    resolve: callbackResolve,
                    reject: callbackReject,
                });
                return promise;
            }
        }
        this.queries.push({
            query: packedQuery,
            variables,
            callbacks: [{
                    resolve: callbackResolve,
                    reject: callbackReject,
                }],
        });
        return promise;
    }
    async runBatch() {
        var _a;
        const batch = this.queries.slice(0);
        this.queries = [];
        this.timeout = undefined;
        let batchedPayload = [];
        for (const pendingQuery of batch) {
            const query = {
                query: pendingQuery.query,
            };
            if (pendingQuery.variables) {
                query.variables = pendingQuery.variables;
            }
            batchedPayload.push(query);
        }
        try {
            const result = await api_base_1.default.queryGraph(batchedPayload);
            if (!result.data ||
                (((_a = result.errors) === null || _a === void 0 ? void 0 : _a.length) > 0)) {
                for (const pendingQuery of batch) {
                    for (const callback of pendingQuery.callbacks) {
                        callback.reject(new GraphqlBatcherError('GraphQL query failed', result.errors));
                    }
                }
            }
            let i = 0;
            for (const pendingQuery of batch) {
                const data = result.data[i];
                pendingQuery.callbacks.forEach(callback => callback.resolve(data));
                i++;
            }
        }
        catch (e) {
            for (const pendingQuery of batch) {
                pendingQuery.callbacks.forEach(callback => callback.reject(e));
            }
        }
    }
}
exports.GraphqlBatcher = GraphqlBatcher;
